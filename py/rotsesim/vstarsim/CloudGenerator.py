# -*- coding: utf-8 -*-
"""
Created on Fri Mar 31 18:50:23 2023

@author: Zachary McIlroy
"""

import numpy as np
import random
import matplotlib.pyplot as plt
import Cloud

class CloudGenerator:
    
    
    # This method generates rectangular clouds within the sky overall and takes an integer between 0 and 100 as the cloud coverage and returns a sky
    # covered by clouds that match that percentage within 10%
    def generateClouds(cloudPercentage : float):
        
        # List of clouds that will have clouds added to it until the cloud percentage argument is reached
        clouds = []
        
        # Area of the sky covered by clouds
        cloudsArea = 0
        
        # Simple approximation for the area of the sky in degrees
        skyArea = 180**2
        
        # This while loop iterates until the percentage of the sky covered by clouds reaches the cloud percentage passed into the method
        while cloudsArea/skyArea < cloudPercentage/100:
            
            # Boolean used to check if a cloud overlaps any already generated clouds in the current clouds array
            overlap = True
            
            # This while loop iterates until a cloud is successfully added to the clouds array
            while overlap == True:
                overlap = False
                
                # This if/else block creates the first cloud to be much larger than the rest to achieve results closer to reality
                if len(clouds) == 0:
                    
                    # Four points are generated by which the rectangular shape can be made. The x1 and y1 coordinate are specifically chosen to be at least
                    # the max width and height of the shape away from the edge of the sky so that no part of the cloud ever goes beyond the edge of the 
                    # visible sky. This would lead to inaccuracy in the area calculations. The size of this first cloud is currently set to 80% of the cloud
                    # coverage. For example, if the cloud coverage was 60%, the first cloud would take up 48% of that
                    x1 = random.uniform(0, 180 - np.sqrt(((cloudPercentage/100)*0.8*180*180)))
                    y1 = random.uniform(0, 180 - np.sqrt(((cloudPercentage/100)*0.8*180*180)))
                    x2 = x1 + np.sqrt(((cloudPercentage/100)*0.8*180*180))
                    y2 = y1 + np.sqrt(((cloudPercentage/100)*0.8*180*180))
                else:
                    # After the first cloud, the rest of the clouds are generated wherever and with a random size, but they do have a minimum possible size
                    # of 6x6 degrees
                    x1 = random.uniform(0, 174)
                    y1 = random.uniform(0, 174)
                    x2 = random.uniform(x1 + 6, 180)
                    y2 = random.uniform(y1 + 6, 180)
                
                # Check if the new cloud overlaps with any existing clouds
                for existing_cloud in clouds:
                    prevCloudPoints = existing_cloud.getPoints()
                    if prevCloudPoints[0]>=x2 or prevCloudPoints[2]<=x1 or prevCloudPoints[3]<=y1 or prevCloudPoints[1]>=y2:
                        pass
                    else:
                        overlap = True
                        break
                
                # This variable calculates the current area with the new cloud's area added, then subtracts 0.1 in order that it can be confirmed that the
                # new cloud would not send the area over the cloud percentage by more than 10%
                tempArea = ((cloudsArea + (x2-x1)*(y2-y1))/skyArea) - 0.1
                
                # This variable calculates the difference between the width and the height
                tempDist = abs((x2 - x1) - (y2 - y1))
                
                # If there is no overlap, the new cloud doesn't make the area exceed the could percentage by more than 10%, and the rectnagular does not
                # have a high diparity between it's height and width, then add the new cloud to the list
                if not overlap and tempArea < cloudPercentage/100 and tempDist/(x2-x1) <= 0.7 and tempDist/(y2-y1) <= 0.7:
                    newCloudPoints = [x1,y1,x2,y2]
                    clouds.append(Cloud.Cloud(newCloudPoints))
                    cloudsArea += (x2-x1)*(y2-y1)
        
        return clouds
    
    
    # Unused and untested method to plot clouds. Duplicated code from StarGenerator method
    def plot_clouds(clouds: list[Cloud]):
        for cloud in clouds:
            plt.plot(cloud.getRA(), cloud.getDec(), marker = 'o', markersize = cloud.getRadius(), color = 'blue')
        plt.xlabel("RA (deg)")
        plt.ylabel("Dec (deg)")
        plt.title("Simulated Sky")
        plt.show()
        
    # Previous iteration of cloud generator when it was thought that generating clouds for every hour at the Atmospheric Calculator level would be most
    # efficient. It turns out this is not the case as many sets of clouds would be needlessly generated
    # def generateCloudsForAllTime(data : pd.DataFrame, ra : float, dec : float, fov : float):
    #     cloudsForAllTime = {}
    #     for index, row in data.iterrows():
    #         cloudsForAllTime[row['time']] = CloudGenerator.CloudGenerator.generateClouds(ra, dec, fov, float(row['hourly']['cloudcover']))
    #     return cloudsForAllTime